{
    "contents" : "tpsco<- function (par, fn, gr = NULL, ..., lower=-1, upper=1,\n                 control = list()) {\n  fn1 <- function(par) fn(par, ...)/p.fnscale\n  mrunif <- function(n,m,lower,upper) {\n    return(matrix(runif(n*m,0,1),nrow=n,ncol=m)*(upper-lower)+lower)\n  }\n  norm <- function(x) sqrt(sum(x*x))\n  rsphere.unif <- function(n,r) {\n    temp <- runif(n)\n    return((runif(1,min=0,max=r)/norm(temp))*temp)\n  }\n  svect <- function(a,b,n,k) {\n    temp <- rep(a,n)\n    temp[k] <- b\n    return(temp)\n  }\n  mrsphere.unif <- function(n,r) {\n    m <- length(r)\n    temp <- matrix(runif(n*m),n,m)\n    return(temp%*%diag(runif(m,min=0,max=r)/apply(temp,2,norm)))\n  }\n  npar <- length(par)\n  lower <- as.double(rep(lower, ,npar))\n  upper <- as.double(rep(upper, ,npar))\n  con <- list(trace = 1, fnscale = 1, maxit = 1000L, maxf = Inf,\n              abstol = -Inf, reltol = 0, REPORT = 10,\n              s = NA, k = 3, p = NA, w = 1/(2*log(2)),\n              c.p = .5+log(2), c.g = .5+log(2), d = NA,\n              v.max = NA, rand.order = TRUE, max.restart=Inf,\n              maxit.stagnate = Inf,\n              vectorize=FALSE, hybrid = FALSE, hybrid.control = NULL,\n              trace.stats = FALSE, type = \"SPSO2007\",SCOND=TRUE,m=5,iter=10,GUASS=TRUE,n=10)\n  nmsC <- names(con)\n  con[(namc <- names(control))] <- control\n  if (length(noNms <- namc[!namc %in% nmsC])) \n    warning(\"unknown names in control: \", paste(noNms, collapse = \", \"))\n  ## Argument error checks\n  if (any(upper==Inf | lower==-Inf))\n    stop(\"fixed bounds must be provided\")\n  \n  p.type <- pmatch(con[[\"type\"]],c(\"SPSO2007\",\"SPSO2011\"))-1\n  if (is.na(p.type)) stop(\"type should be one of \\\"SPSO2007\\\", \\\"SPSO2011\\\"\")\n  \n  p.n<-con[[\"n\"]]   #均匀粒子\n  \n  p.iter<-con[[\"iter\"]]  #二种群迭代iter次后和一种群进行粒子交换\n  p.m<-con[[\"m\"]]  #一种群每迭代m次，和二种群进行粒子交换\n  p.scond<-con[[\"SCOND\"]]  #是否使用二分粒子群\n  p.guass=con[[\"GUASS\"]]   #是否使用均匀扰动\n  p.trace <- con[[\"trace\"]]>0L # provide output on progress?\n  p.fnscale <- con[[\"fnscale\"]] # scale funcion by 1/fnscale\n  p.maxit <- con[[\"maxit\"]] # maximal number of iterations\n  p.maxf <- con[[\"maxf\"]] # maximal number of function evaluations\n  p.abstol <- con[[\"abstol\"]] # absolute tolerance for convergence\n  p.reltol <- con[[\"reltol\"]] # relative minimal tolerance for restarting\n  p.report <- as.integer(con[[\"REPORT\"]]) # output every REPORT iterations\n  p.s <- ifelse(is.na(con[[\"s\"]]),ifelse(p.type==0,floor(10+2*sqrt(npar)),40),\n                con[[\"s\"]]) # swarm size\n  p.p <- ifelse(is.na(con[[\"p\"]]),1-(1-1/p.s)^con[[\"k\"]],con[[\"p\"]]) # average % of informants\n  p.w0 <- con[[\"w\"]] # exploitation constant\n  if (length(p.w0)>1) {\n    p.w1 <- p.w0[2]\n    p.w0 <- p.w0[1]\n  } else {\n    p.w1 <- p.w0\n  }\n  p.c.p <- con[[\"c.p\"]] # local exploration constant\n  p.c.g <- con[[\"c.g\"]] # global exploration constant\n  p.d <- ifelse(is.na(con[[\"d\"]]),norm(upper-lower),con[[\"d\"]]) # domain diameter\n  p.vmax <- con[[\"v.max\"]]*p.d # maximal velocity\n  p.randorder <- as.logical(con[[\"rand.order\"]]) # process particles in random order?\n  p.maxrestart <- con[[\"max.restart\"]] # maximal number of restarts\n  p.maxstagnate <- con[[\"maxit.stagnate\"]] # maximal number of iterations without improvement\n  p.vectorize <- as.logical(con[[\"vectorize\"]]) # vectorize?\n  if (is.character(con[[\"hybrid\"]])) {\n    p.hybrid <- pmatch(con[[\"hybrid\"]],c(\"off\",\"on\",\"improved\"))-1\n    if (is.na(p.hybrid)) stop(\"hybrid should be one of \\\"off\\\", \\\"on\\\", \\\"improved\\\"\")\n  } else {\n    p.hybrid <- as.integer(as.logical(con[[\"hybrid\"]])) # use local BFGS search\n  }\n  p.hcontrol <- con[[\"hybrid.control\"]] # control parameters for hybrid optim\n  if (\"fnscale\" %in% names(p.hcontrol))\n    p.hcontrol[\"fnscale\"] <- p.hcontrol[\"fnscale\"]*p.fnscale\n  else\n    p.hcontrol[\"fnscale\"] <- p.fnscale\n  p.trace.stats <- as.logical(con[[\"trace.stats\"]]) # collect detailed stats?\n  \n  \n  if (p.trace) {\n    message(\"S=\",p.s,\", K=\",con[[\"k\"]],\", p=\",signif(p.p,4),\", w0=\",\n            signif(p.w0,4),\", w1=\",\n            signif(p.w1,4),\", c.p=\",signif(p.c.p,4),\n            \", c.g=\",signif(p.c.g,4))\n    message(\"v.max=\",signif(con[[\"v.max\"]],4),\n            \", d=\",signif(p.d,4),\", vectorize=\",p.vectorize,\n            \", hybrid=\",c(\"off\",\"on\",\"improved\")[p.hybrid+1])\n    if (p.trace.stats) {\n      stats.trace.it <- c()\n      stats.trace.error <- c()\n      stats.trace.f <- NULL\n      stats.trace.x <- NULL\n    }\n  }\n  ## Initialization\n  if (p.reltol!=0) p.reltol <- p.reltol*p.d\n  if (p.vectorize) {\n    lowerM <- matrix(lower,nrow=npar,ncol=p.s)\n    upperM <- matrix(upper,nrow=npar,ncol=p.s)\n  }\n  X <- mrunif(npar,p.s,lower,upper)\n  if (!any(is.na(par)) && all(par>=lower) && all(par<=upper)) X[,1] <- par\n  if (p.type==0) {\n    V <- (mrunif(npar,p.s,lower,upper)-X)/2\n  } else { ## p.type==1\n    V <- matrix(runif(npar*p.s,min=as.vector(lower-X),max=as.vector(upper-X)),npar,p.s)\n    p.c.p2 <- p.c.p/2 # precompute constants\n    p.c.p3 <- p.c.p/3\n    p.c.g3 <- p.c.g/3\n    p.c.pg3 <- p.c.p3+p.c.g3\n  }\n  if (!is.na(p.vmax)) { # scale to maximal velocity\n    temp <- apply(V,2,norm)\n    temp <- pmin.int(temp,p.vmax)/temp\n    V <- V%*%diag(temp)\n  }\n  f.x <- apply(X,2,fn1) # first evaluations\n  stats.feval <- p.s\n  P <- X\n  f.p <- f.x\n  P.improved <- rep(FALSE,p.s)\n  i.best <- which.min(f.p)\n  error <- f.p[i.best]\n  init.links <- TRUE\n  if (p.trace && p.report==1) {\n    message(\"It 1: fitness=\",signif(error,4))\n    if (p.trace.stats) {\n      stats.trace.it <- c(stats.trace.it,1)\n      stats.trace.error <- c(stats.trace.error,error)\n      stats.trace.f <- c(stats.trace.f,list(f.x))\n      stats.trace.x <- c(stats.trace.x,list(X))\n    }\n  }\n  \n  #Initialization  function\n  init<-function(npar,s,lower,upper){\n    X=mrunif(npar,s,lower,upper)\n    V=(mrunif(npar,s,lower,upper)-X)/2\n    \n    f.x<-apply(X,2,fn1)\n    return(list(X,V,f.x))\n  }\n  \n  #二种群迭代\n  inter2<-function(x,y,w,p){\n  \n    m<-which.min(y[[3]])\n    g<-matrix(rep(y[[1]][,m],p.s),nrow=npar,ncol=p.s)\n    g[,m]<-x[[1]][,m]\n    x[[2]]<-w*x[[2]]+runif(npar,0,p.c.p)*(y[[1]]-x[[1]])+runif(npar,0,p.c.g)*(p-x[[1]])+runif(npar,0,p.c.g)*(g-x[[1]])\n   \n    x[[1]]=x[[1]]+x[[2]]\n    \n    #check bound\n    temp <-x[[1]]<lower\n    if (any(temp)) {\n      x[[1]][temp] <- max(lower)\n      x[[2]][temp] <- 0\n    }\n    temp <- x[[1]]>upper\n    if (any(temp)) {\n      x[[1]][temp] <-min(upper)\n      x[[2]][temp] <- 0\n    }\n    \n    x[[3]]<-apply(x[[1]],2,fn1)\n    return(x)\n  }\n  \n  #二种群初始化\n  if(p.scond){\n    p2<-init(npar,p.s,lower,upper)\n    p.p2<-p2\n    \n    \n    \n    \n  }\n  \n  #Guass  均匀变异\n  Guass<-function(x,Lower,Upper,n){\n    rn<-matrix(runif(n*npar,0,1),nrow=npar,ncol=n)\n\n    guass<-Lower+rn*(Upper-Lower)\n   \n    x<-x+guass\n    temp<-x<min(lower)\n    x[temp]<-min(lower)\n    temp<-x>max(upper)\n    x[temp]<-max(upper)\n    \n   \n    \n    return(x)\n    \n  }\n\n  ## Iterations\n  stats.iter <- 1\n  stats.restart <- 0\n  stats.stagnate <- 0\n  \n  while (stats.iter<p.maxit && stats.feval<p.maxf && error>p.abstol &&\n           stats.restart<p.maxrestart && stats.stagnate<p.maxstagnate) {\n    stats.iter <- stats.iter+1\n    scond.stat<-FALSE\n    if (p.p!=1 && init.links) {\n      links <- matrix(runif(p.s*p.s,0,1)<=p.p,p.s,p.s)\n      diag(links) <- TRUE\n    }\n    \n\n    \n    ## The swarm moves\n    if (!p.vectorize) {\n      if (p.randorder) {\n        index <- sample(p.s)\n      } else {\n        index <- 1:p.s\n      }\n      for (i in index) {\n        if (p.p==1)\n          j <- i.best\n        else\n          j <- which(links[,i])[which.min(f.p[links[,i]])] # best informant\n        temp <- (p.w0+(p.w1-p.w0)*max(stats.iter/p.maxit,stats.feval/p.maxf))\n        \n        V[,i] <- temp*V[,i] # exploration tendency\n        if (p.type==0) {\n          \n          \n          V[,i] <- V[,i]+runif(npar,0,p.c.p)*(P[,i]-X[,i]) # exploitation\n          if (i!=j) V[,i] <- V[,i]+runif(npar,0,p.c.g)*(P[,j]-X[,i])\n        } else { # SPSO 2011\n          if (i!=j)\n            temp <- p.c.p3*P[,i]+p.c.g3*P[,j]-p.c.pg3*X[,i] # Gi-Xi\n          else\n            temp <- p.c.p2*P[,i]-p.c.p2*X[,i] # Gi-Xi for local=best\n          V[,i] <- V[,i]+temp+rsphere.unif(npar,norm(temp))\n        }\n        if (!is.na(p.vmax)) {\n          temp <- norm(V[,i])\n          if (temp>p.vmax) V[,i] <- (p.vmax/temp)*V[,i]\n        }\n        X[,i] <- X[,i]+V[,i]\n        \n        d.sigma<-apply(X,1,sd)\n        d.mu<-apply(X,1,mean)\n        \n        temp1<-d.mu-d.sigma-X[,i]>0\n        temp2<-d.mu-d.sigma-X[,i]<=0&d.mu+d.sigma-X[,i]>=0\n        temp3<-d.mu+d.sigma-X[,i]<0\n       \n        pd<-NULL\n        \n        if(any(temp1))\n          pd[temp1]=d.mu[temp1]-d.sigma[temp1]-X[,i][temp1]\n        if(any(temp2))\n          pd[temp2]=abs(d.mu[temp2]-X[,i][temp2])\n        if(any(temp3))\n          pd[temp3]=X[,i][temp3]-(d.mu[temp3]+d.sigma[temp3])\n         \n        \n        \n        #均匀变异\n        if(p.guass){\n          X_G<-NULL         \n          X_G<-Guass(X[,i],-pd,pd,p.n)          \n          X_G<-cbind(X_G,X[,i])\n          X_GF<-apply(X_G[,1:p.n],2,fn1)\n          X_GF<-c(X_GF,f.x[i])\n          X[,i]<-X_G[which.min(X_GF)]\n        }\n        ## Check bounds\n        temp <- X[,i]<lower\n        if (any(temp)) {\n          X[temp,i] <- lower[temp]\n          V[temp,i] <- 0\n        }\n        temp <- X[,i]>upper\n        if (any(temp)) {\n          X[temp,i] <- upper[temp]\n          V[temp,i] <- 0\n        }\n        \n        ## Evaluate function\n        if (p.hybrid==1) {\n          temp <- optim(X[,i],fn,gr,...,method=\"L-BFGS-B\",lower=lower,\n                        upper=upper,control=p.hcontrol)\n          V[,i] <- V[,i]+temp$par-X[,i] # disregards any v.max imposed\n          X[,i] <- temp$par\n          f.x[i] <- temp$value\n          stats.feval <- stats.feval+as.integer(temp$counts[1])\n        } else {\n          f.x[i] <- fn1(X[,i])\n          stats.feval <- stats.feval+1\n        }\n        if (f.x[i]<f.p[i]) { # improvement\n          P[,i] <- X[,i]\n          f.p[i] <- f.x[i]\n          if (f.p[i]<f.p[i.best]) {\n            i.best <- i\n            if (p.hybrid==2) {\n              temp <- optim(X[,i],fn,gr,...,method=\"L-BFGS-B\",lower=lower,\n                            upper=upper,control=p.hcontrol)\n              V[,i] <- V[,i]+temp$par-X[,i] # disregards any v.max imposed\n              X[,i] <- temp$par\n              P[,i] <- temp$par\n              f.x[i] <- temp$value\n              f.p[i] <- temp$value\n              stats.feval <- stats.feval+as.integer(temp$counts[1])\n            }\n          }\n        }\n        if (stats.feval>=p.maxf) break\n     \n      \n      \n      }\n     \n\n\n    } else {\n      if (p.p==1)\n        j <- rep(i.best,p.s)\n      else # best informant\n        j <- sapply(1:p.s,function(i)\n          which(links[,i])[which.min(f.p[links[,i]])]) \n      temp <- (p.w0+(p.w1-p.w0)*max(stats.iter/p.maxit,stats.feval/p.maxf))\n      V <- temp*V # exploration tendency\n      if (p.type==0) {\n        V <- V+mrunif(npar,p.s,0,p.c.p)*(P-X) # exploitation\n        temp <- j!=(1:p.s)\n        V[,temp] <- V[,temp]+mrunif(npar,sum(temp),0,p.c.p)*(P[,j[temp]]-X[,temp])\n      } else { # SPSO 2011\n        temp <- j==(1:p.s)\n        temp <- P%*%diag(svect(p.c.p3,p.c.p2,p.s,temp))+\n          P[,j]%*%diag(svect(p.c.g3,0,p.s,temp))-\n          X%*%diag(svect(p.c.pg3,p.c.p2,p.s,temp)) # G-X\n        V <- V+temp+mrsphere.unif(npar,apply(temp,2,norm))\n      }\n      if (!is.na(p.vmax)) {\n        temp <- apply(V,2,norm)\n        temp <- pmin.int(temp,p.vmax)/temp\n        V <- V%*%diag(temp)\n      }\n      X <- X+V\n      ## Check bounds\n      temp <- X<lowerM\n      if (any(temp)) {\n        X[temp] <- lowerM[temp] \n        V[temp] <- 0\n      }\n      temp <- X>upperM\n      if (any(temp)) {\n        X[temp] <- upperM[temp]\n        V[temp] <- 0\n      }\n      \n      ## Evaluate function\n      if (p.hybrid==1) { # not really vectorizing\n        for (i in 1:p.s) {\n          temp <- optim(X[,i],fn,gr,...,method=\"L-BFGS-B\",lower=lower,\n                        upper=upper,control=p.hcontrol)\n          V[,i] <- V[,i]+temp$par-X[,i] # disregards any v.max imposed\n          X[,i] <- temp$par\n          f.x[i] <- temp$value\n          stats.feval <- stats.feval+as.integer(temp$counts[1])\n        }\n      } else {\n        f.x <- apply(X,2,fn1)\n        stats.feval <- stats.feval+p.s\n      }\n      temp <- f.x<f.p\n      if (any(temp)) { # improvement\n        P[,temp] <- X[,temp]\n        f.p[temp] <- f.x[temp]\n        i.best <- which.min(f.p)\n        if (temp[i.best] && p.hybrid==2) { # overall improvement\n          temp <- optim(X[,i.best],fn,gr,...,method=\"L-BFGS-B\",lower=lower,\n                        upper=upper,control=p.hcontrol)\n          V[,i.best] <- V[,i.best]+temp$par-X[,i.best] # disregards any v.max imposed\n          X[,i.best] <- temp$par\n          P[,i.best] <- temp$par\n          f.x[i.best] <- temp$value\n          f.p[i.best] <- temp$value\n          stats.feval <- stats.feval+as.integer(temp$counts[1])\n        }\n      }\n      if (stats.feval>=p.maxf) break\n    }\n    \n  \n  \n   \n\n    #二种群粒子迭代\n   if(p.scond){\n      scond.stat<-TRUE\n      \n      #进行迭代， 当粒子聚集程度很高的时候，倒转粒子\n      p2<-inter2(p2,p.p2,p.w0,P[,i.best])\n      \n      #二种群粒子最优记录\n      temp<-p2[[3]]-p.p2[[3]]<0\n      p.p2[[1]][,temp]<-p2[[1]][,temp]\n      p.p2[[3]][temp]<-p2[[3]][temp]\n      \n    }\n \n    p.m<-ifelse(p.m<=2,2,as.integer(p.maxit%/%2*(p.maxit-stats.iter)/p.maxit))\n   \n     \n    #信息交流\n    if(scond.stat&&p.scond&&stats.iter%%p.m==0){\n     \n     temp<-c(p.p2[[3]],f.p)\n     min<-which.min(temp)\n    \n     if(min<=p.s){\n       max<-which.max(f.p)\n       P[,max]<-p.p2[[1]][,min]\n       f.p[max]<-p.p2[[3]][min]\n       i.best=max\n       \n      \n     }else{\n       p.p2[[1]][,which.max(p.p2[[3]])]<-P[,min-p.s]\n       p.p2[[3]][which.max(p.p2[[3]])]<-f.p[min-p.s]\n            \n     }\n    }\n   \n   \n    if (p.reltol!=0) {\n      d <- X-P[,i.best]\n      d <- sqrt(max(colSums(d*d)))\n      if (d<p.reltol) {\n        X <- mrunif(npar,p.s,lower,upper)\n        V <- (mrunif(npar,p.s,lower,upper)-X)/2\n        if (!is.na(p.vmax)) {\n          temp <- apply(V,2,norm)\n          temp <- pmin.int(temp,p.vmax)/temp\n          V <- V%*%diag(temp)\n        }\n        stats.restart <- stats.restart+1\n        if (p.trace) message(\"It \",stats.iter,\": restarting\")\n      }\n    }\n    init.links <- f.p[i.best]==error # if no overall improvement\n    stats.stagnate <- ifelse(init.links,stats.stagnate+1,0)\n    error <- f.p[i.best]\n    if (p.trace && stats.iter%%p.report==0) {\n      if (p.reltol!=0) \n        message(\"It \",stats.iter,\": fitness=\",signif(error,4),\n                \", swarm diam.=\",signif(d,4))\n      else\n        message(\"It \",stats.iter,\": fitness=\",signif(error,4))\n      if (p.trace.stats) {\n        stats.trace.it <- c(stats.trace.it,stats.iter)\n        stats.trace.error <- c(stats.trace.error,error)\n        stats.trace.f <- c(stats.trace.f,list(f.x))\n        stats.trace.x <- c(stats.trace.x,list(X))\n      }\n    }\n  }\n  \n  if (error<=p.abstol) {\n    msg <- \"Converged\"\n    msgcode <- 0\n  } else if (stats.feval>=p.maxf) {\n    msg <- \"Maximal number of function evaluations reached\"\n    msgcode <- 1\n  } else if (stats.iter>=p.maxit) {\n    msg <- \"Maximal number of iterations reached\"\n    msgcode <- 2\n  } else if (stats.restart>=p.maxrestart) {\n    msg <- \"Maximal number of restarts reached\"\n    msgcode <- 3\n  } else {\n    msg <- \"Maximal number of iterations without improvement reached\"\n    msgcode <- 4\n  }\n \n  if (p.trace) message(msg)\n  \n  o <- list(par=P[,i.best],value=f.p[i.best],\n            counts=c(\"function\"=stats.feval,\"iteration\"=stats.iter,\n                     \"restarts\"=stats.restart),\n            convergence=msgcode,message=msg)\n  if (p.trace && p.trace.stats) o <- c(o,list(stats=list(it=stats.trace.it,\n                                                         error=stats.trace.error,\n                                                         f=stats.trace.f,\n                                                         x=stats.trace.x)))\n  return(o)\n}\ntest_f<-function(x){\n  a<-sum(x^2-10*cos(2*pi*x)+10)\n  return(a)\n  \n}\n\n\n\n\npm<-proc.time()\npso<-tpsco(rep(NA,30),test_f,lower=-10,upper=10,control=list(maxit=100,trace=0,REPORT=TRUE,SCOND=T,GUASS=T,m=10,n=10,s=40))\nwait<-proc.time()-pm\n",
    "created" : 1401114105946.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "331|12|399|4|\n443|22|457|4|\n476|24|479|2|\n482|35|485|2|\n",
    "hash" : "4061321759",
    "id" : "545B7DF",
    "lastKnownWriteTime" : 1402897075,
    "path" : "~/paper/lunwen/pso/VPSO/TPSCO.R",
    "project_path" : "TPSCO.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}